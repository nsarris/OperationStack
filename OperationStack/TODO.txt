DONE 1. Add one more overload to be able to return IOperationResult or IOperationResult<T> 
straight from delegate. The flow will append this to the original and continue 
(caution if user returns the same ref do nothing). The result data and any other data
will be copied over
??? How to handle inner responses?

2. Error Handling
OnError 
OnError(predicate)
OnErrorOf<T> (T1,T2) (T1,T2,T3) (IEnumerable<Type> errorTypes)
OnExceptionOf<T> (T1,T2) (T1,T2,T3) (IEnumerable<Type> exceptionTypes)
*Exceptions entering are tagged handled unless "rethrown" (handled = false)

3. Final flow
Success (will enter if no errors)
Fail (will enter at least one error)
OnUnhandledExceptions (will enter if at least one unhandled exception)
Finally (goes here no matter what)

4. Validate (sequence etc)

5. Timeout 
	i) Stack / Block
	ii) With Token / With WhenAny(Task(token), Task.Delay))

6. Parallel Tasks in Block

7. async???

Func<IOperationResult,Tin,OperationFlow, Task<Tout>>

8. Inject logger sercice/subject

DONE 9. Retry needs to reuse resp


10. Refactor Result -> Response
Introduce sections/blocks/tags
Current section/block/tag

Add events per tag
Add other responses per tag -> Events are added/enumerated into this.Events

Resp.AddEvent -> to current block
Resp.Append -> Events appended, original disposed
Resp.AddInner -> Events appened or enumerated, original added in collection


